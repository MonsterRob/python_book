1 技术盲点在哪里？

2 掌握程度怎么样？

3 熟练程度怎么样？

流畅的Python 读书笔记 
    
    关键词：始基单元 即编程语言词汇即关键字
    特殊方法的存在是为了让解释器调用
 

特殊方法：

    与运算符无关的：
    
        字符串表示形式：__repr__ __str__ __formats__ __bytes__
        数值转换：__abs__ __bool__ __complex__ __int__ __float__ __hash__ __index__
        集合模拟：__len__ __getitem__ __setitem__ __delitem__ __contains__
        迭代枚举：__iter__ __reversed__ __next__
        可调用模拟：__call__
        上下文管理:__enter__ __exit__
        实例创建和销毁:__new__ __init__ __del__
        属性管理:__getattr__ getattribute__ __setattr__ __delattr__ __dir__
        属性描述符:__get__ __set__ __delete__
        根类相关的服务:__prepare__ __instancechcek__ __subclasscheck__
    
    与运算符有关的：
        
        很多
数据结构

    容器序列：list tuple deque Queue
    扁平序列 str bytes bytearray memeryviwe
    可变序列 list deque ...
    不可变序列 tuple str bytes
    列表推导式 生成器表达式
    就地 原地 改变
    切片操作
    Python tutor 网站分析工具
    不要将可变对象放在元组里/ 增量操作不是原子的
    += *= 区别对待可变和不可变序列
    Timsort Tim Peters
    
字典和集合
    
    {key:value, key1:value1,...}
    散列表的原理？
    对象的生命周期 散列值不变
    字典的多种构造方式
    字典推到式
    defaultdict 与可调用对象
    __slots__改变实例属性的存储方式
    
文本和字节序列

    人类使用文本 计算机使用字节序列
   
函数--对象

    一等对象：在运行时创建 能赋值给变量 能作为参数传递给函数 能作为函数的额返回结果
    对象的属性：数据属性 可调用属性
    高阶函数
    匿名函数
    可调用对象 调用运算符 
    生成器函数---> 生成器
    函数内省
    函数签名
    可调用对象协议
    函数注解
    函数式编程：operator functools
    partial 函数
    
6使用一等函数实现设计模式

     符合模式并不表示做的对
     符号表
     
7装饰器和闭包

        元编程技术 装饰器 元类 在程序运行时改变其行为
        导入时
        运行时
        自由变量
        函数编译时会记录自由变量
        闭包函数会持有自由变量
        赋值产生的副作用
        py2 使用字典解决nonlocal问题
        装饰器参数一致性问题
        装饰器函数与被装饰函数接受同样的参数
        保留被装饰函数的原信息
        参数化装饰器
        元编程领域
        
8面向对象 类 实例 一切皆对象

        名称不是对象
        元祖的不可变性具体所指
        深浅复制
        弱引用

9 Python风格的对象

    对象的字符串表示
    私有属性 受保护属性
    __slots__ 节省内存 副作用限制绑定其他名称
    类属性可用于为实例属性提供默认值

10序列的修改

    不可变扁平序列对象 str bytes ...
    把协议当做正式接口
    协议和🦆类型
    序列协议 协议的实现基于内建函数
    看起来像 就足够了
    属性查找失败 调用__getattr__
    属性查找顺序：实例--类--继承树--->协议
    __getattr__ 只有获取不存在的属性时才会调取此方法
    __getattribute__ 只要获取属性，就会调取此方法
    任何属性的设置都会调用 __setattr__
    非正式接口

11从协议到抽象基类 

    每个方法，本质都是函数
    猴子补丁：运行时给类或者模块绑定新的属性
    对象的类型无关紧要，重要的是实现相关协议
    还需再议
    动态 强类型语言
    内置类型不允许打猴子补丁
    🐒
    交互设计精髓 📚
    
12多继承 方法解析顺序    
    
    菱形问题

13操作符重载问题

14 控制流程

    迭代器模式 惰性获取数据
    iter 函数 与__iter__方法 __getitem__ 任何对象可迭代 即实现了__getitem__方法
    迭代对象x iter(x)
    从可迭代的对象中获取迭代器 iter 获取迭代器
    生成器函数 yield
    生成器函数的定义体通常有循环
    标准库生成器函数
    归约函数 
    argparse 读取命令行选项
    .send()方法
    双向交换数据
    将数据发给生成器 生成器生成新的数据
    next 只能获取数据
    send 可发送数据 获取数据
    协程和生成器概念不同
    协程是数据的消费者
    
15上下文管理器/else语句块

    协议：__enter__ __exit__
    __enter__ 有返回值与没有返回值
    __exit__收尾工作
    else 子句 正常收尾 break 出现不执行
    上下文管理器对象
    类实现 使用协议 函数实现使用contextlib.contextmanager
    with 与生成器函数
    如何处理异常
    取得原谅比获得许可容易
    常用对象 不常用对象
    产出和让渡控制权
    yield 流程控制工具
    流程控制--直流 分支 循环 让渡
    
16协程

    协程使用生成器函数定义
    一开始无法发送数据 需要启动协程
    协程的四个状态 
    预激协程
    遇到yield 暂停执行 返回客户代码
    原来知识是这么重要
    静态数据 动态数据 实时数据
    调用方
    协程预激装饰器
    yield from x 语句结构 首先iter(x) --> 获取迭代器，
    yield from +任何可迭代对象
    yield from 产出值由内部负责
    每次迭代 发送一个迭代信号 获取一个值

17 客户端

   sys.stdout.flush() 刷新输出缓存, 不刷新不显示，默认换行刷新
   非正规基准测试
   GIL 对IO的影响大小 不大
   执行的是字节码
   标准库中IO阻塞性操作会释放GIL,允许其他线程执行 sleep()函数也会释放GIL
   CPU 密集型任务绕开GIL 
   
18元编程领域

    属性 数据+方法 方法：可调用的属性
    统一访问原则
    实例的__dict__属性
    描述符
    动态属性和特性
    描述符是对多个属性使用相同存取逻辑的一种方式
    描述符 是类 实现了特性的协议
    理解描述符是精通Python 的关键
    特性工厂函数
    描述符协议
    描述符的用法：创建一个实例，用作另一个类的类属性，注意：是类属性
    类是描述符
    类属性可为实例属性提供默认值
    托管类 ：将描述符实例用作类属性的类
    
    描述符类 描述符实例
    托管类 托管实例
    存储属性 托管属性
    描述符类解决什么问题
    
    托管实例 托管类的实例
    凭空捏造的名称
    属性名称

19精通Python

    基本语法
    库
    宣扬善良的人需要的是你的善良、温顺，但他们并不打算对你善良，记住这一点
    危险会来自哪里，如何应对？
    政治权术 制造气氛
    结果导向 谁在意结果
    生活中有很多事情简单到不值一提，但人们大都会忽略它
19属性和特性

    封装性
    属性 特性
    数据属性换成特性
    抽象特性
    定义特性：特性工厂函数 描述符
    实例属性的寻找方式
    特性管理实例属性的存取
    事实